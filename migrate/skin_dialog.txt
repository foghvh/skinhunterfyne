// skinhunter/ui/skin_dialog.go
package ui

import (
	"fmt"
	"image/color"
	"log"

	"skinhunter/data"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/layout"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
)

// ShowSkinDialog displays the detailed skin dialog.
func ShowSkinDialog(skin data.Skin, allChromasForChamp []data.Chroma, parent fyne.Window) {
	log.Printf("Showing dialog for skin: %s (ID: %d)", skin.Name, skin.ID)

	selectedChromaID := new(int)
	*selectedChromaID = skin.ID

	filteredChromas := make([]data.Chroma, 0)
	if allChromasForChamp != nil {
		for _, ch := range allChromasForChamp {
			if ch.OriginSkinID == skin.ID {
				filteredChromas = append(filteredChromas, ch)
			}
		}
	}
	log.Printf("Filtered %d chromas for skin ID %d", len(filteredChromas), skin.ID)

	// Left Side Elements
	// *** FIX: NewAsyncImage now returns only the widget ***
	splashImage := NewAsyncImage(0, 0) // Use 0,0 for auto-size
	splashImage.FillMode = canvas.ImageFillContain
	splashUrl := data.GetSkinSplashURL(skin)
	// *** FIX: Call SetImageURL with correct arguments ***
	SetImageURL(splashImage, splashUrl) // Pass widget, url

	desc := skin.Description
	if desc == "" {
		desc = "This skin does not have a description."
	}
	descriptionLabel := widget.NewLabel(desc)
	descriptionLabel.Wrapping = fyne.TextWrapWord
	descriptionScroll := container.NewScroll(descriptionLabel)
	descriptionScroll.SetMinSize(fyne.NewSize(300, 100))
	warningLabel := widget.NewLabel("This skin may not work properly due to game updates")
	warningIcon := widget.NewIcon(theme.WarningIcon())
	warningBox := container.NewPadded(container.NewHBox(warningIcon, warningLabel))

	leftPanel := container.NewVBox(
		// *** FIX: Use splashImage directly in layout ***
		splashImage,
		descriptionScroll,
		warningBox,
	)

	// Right Side Elements (declaration of downloadButton moved up)
	var downloadButton *widget.Button
	downloadButtonText := func() string { /* ... same ... */
		if *selectedChromaID != skin.ID {
			return "Download Chroma"
		}
		return "Download Skin"
	}
	modelViewerLink := widget.NewHyperlink("View on Model viewer", parseURL(data.KhadaUrl(skin.ID, 0)))
	modelInfoIcon := newIconButton(theme.InfoIcon(), func() { dialog.ShowInformation("Model Viewer Info", "...", parent) })
	modelViewerLinkBox := container.NewHBox(modelViewerLink, modelInfoIcon)
	chromaTitle := widget.NewLabel("Chromas")
	chromaInfoIcon := newIconButton(theme.InfoIcon(), func() { dialog.ShowInformation("Chroma Info", "...", parent) })
	chromaTitleBox := container.NewHBox(chromaTitle, chromaInfoIcon)

	updateChromaSelection := func(newID int) { /* ... same ... */
		if *selectedChromaID == newID {
			return
		}
		*selectedChromaID = newID
		modelViewerLink.SetURL(parseURL(data.KhadaUrl(skin.ID, newID)))
		if downloadButton != nil {
			downloadButton.SetText(downloadButtonText())
		}
	}

	// Tab 1: Circles
	circlesGrid := container.NewGridWithColumns(4)
	circlesGrid.Add(createChromaCircleItem("Default", nil, skin.ID, updateChromaSelection)) // Call is already correct
	for _, chroma := range filteredChromas {
		circlesGrid.Add(createChromaCircleItem(chroma.Name, chroma.Colors, chroma.ID, updateChromaSelection)) // Call is already correct
	}
	circlesScroll := container.NewScroll(circlesGrid)
	circlesTabContent := container.NewMax(circlesScroll)

	// Tab 2: Images
	imagesGrid := container.NewGridWithColumns(4)
	imagesGrid.Add(createChromaImageItem("Default", "", skin.ID, updateChromaSelection)) // Call is already correct
	for _, chroma := range filteredChromas {
		imgURL := data.GetChromaImageURL(chroma)
		imagesGrid.Add(createChromaImageItem(chroma.Name, imgURL, chroma.ID, updateChromaSelection)) // Call is already correct
	}
	imagesScroll := container.NewScroll(imagesGrid)
	imagesTabContent := container.NewMax(imagesScroll)

	chromaTabs := container.NewAppTabs(
		container.NewTabItem("Circles", circlesTabContent),
		container.NewTabItem("Images", imagesTabContent),
	)
	creditsText := "This is going to consume a credit"
	creditsInfoLabel := widget.NewLabel(creditsText)
	creditsBox := container.NewHBox(widget.NewIcon(theme.InfoIcon()), creditsInfoLabel)
	rightPanel := container.NewVBox(modelViewerLinkBox, widget.NewSeparator(), chromaTitleBox, chromaTabs, creditsBox)

	// Combine Panels
	dialogContentSplit := container.NewHSplit(container.NewPadded(leftPanel), container.NewPadded(rightPanel))
	dialogContentSplit.Offset = 0.55

	// Action Buttons
	downloadButton = widget.NewButtonWithIcon(downloadButtonText(), theme.DownloadIcon(), func() { /* ... same download logic ... */
		downloadID := *selectedChromaID
		downloadType := "Skin"
		downloadName := skin.Name
		if downloadID != skin.ID {
			downloadType = "Chroma"
			for _, ch := range filteredChromas {
				if ch.ID == downloadID {
					downloadName = ch.Name
					break
				}
			}
		}
		log.Printf("DOWNLOAD ACTION: Type=%s, Name=%s, ID=%d", downloadType, downloadName, downloadID)
		fyne.CurrentApp().SendNotification(&fyne.Notification{Title: "Download Requested", Content: fmt.Sprintf("Downloading %s: %s (ID: %d)", downloadType, downloadName, downloadID)})
	})
	var customDialog dialog.Dialog
	closeButton := widget.NewButton("Close", func() { customDialog.Hide() })
	actionButtons := container.NewHBox(layout.NewSpacer(), closeButton, downloadButton)
	finalDialogContent := container.NewBorder(nil, actionButtons, nil, nil, dialogContentSplit)
	customDialog = dialog.NewCustom(skin.Name, "Dismiss", finalDialogContent, parent)
	customDialog.Resize(fyne.NewSize(850, 550))
	customDialog.Show()
}

// Helper to create a chroma item card (Circle version)
// (Definition remains the same - already correct)
func createChromaCircleItem(name string, hexColors []string, itemID int, onSelect func(id int)) fyne.CanvasObject {
	const visualSize float32 = 48
	const itemWidth float32 = 80
	const itemHeight float32 = 110
	placeholderRect := canvas.NewRectangle(theme.ButtonColor())
	placeholderRect.SetMinSize(fyne.NewSize(visualSize, visualSize))
	displayContainer := container.NewStack(placeholderRect)
	if name == "Default" {
		icon := widget.NewIcon(theme.CancelIcon())
		displayContainer.Add(container.NewCenter(icon))
	} else if len(hexColors) > 0 { /* ... color logic ... */
		clr1, err1 := data.ParseHexColor(hexColors[0])
		if err1 != nil {
			clr1 = color.NRGBA{R: 128, G: 128, B: 128, A: 255}
		}
		if len(hexColors) == 1 || hexColors[1] == "" {
			circle := canvas.NewCircle(clr1)
			circle.StrokeWidth = 1
			circle.StrokeColor = theme.InputBorderColor()
			displayContainer.Add(container.NewCenter(circle))
		} else {
			clr2, err2 := data.ParseHexColor(hexColors[1])
			if err2 != nil {
				clr2 = clr1
			}
			gradient := canvas.NewHorizontalGradient(clr1, clr2)
			gradient.SetMinSize(fyne.NewSize(visualSize, visualSize))
			displayContainer.Objects = []fyne.CanvasObject{gradient}
			border := canvas.NewRectangle(color.Transparent)
			border.StrokeColor = theme.InputBorderColor()
			border.StrokeWidth = 1
			border.Resize(fyne.NewSize(visualSize, visualSize))
			displayContainer.Add(border)
		}
	} else {
		icon := widget.NewIcon(theme.QuestionIcon())
		displayContainer.Add(container.NewCenter(icon))
	}
	displayContainer.Resize(fyne.NewSize(visualSize, visualSize))
	nameLabel := widget.NewLabel(name)
	nameLabel.Alignment = fyne.TextAlignCenter
	nameLabel.Truncation = fyne.TextTruncateEllipsis
	nameLabel.Wrapping = fyne.TextWrapOff
	itemContent := container.NewVBox(container.NewCenter(displayContainer), nameLabel)
	itemWrapper := container.NewPadded(itemContent)
	itemWrapper.Resize(fyne.NewSize(itemWidth, itemHeight))
	card := newTappableCard(itemWrapper, func() { onSelect(itemID) })
	return card
}

// Helper to create a chroma item card (Image version)
// *** FIX Needed Here as well! ***
func createChromaImageItem(name, imageURL string, itemID int, onSelect func(id int)) fyne.CanvasObject {
	const imgSize float32 = 64
	const itemWidth float32 = 80
	const itemHeight float32 = 110
	var visualElement fyne.CanvasObject

	if name == "Default" {
		icon := widget.NewIcon(theme.CancelIcon())
		iconContainer := container.NewCenter(icon)
		placeholder := canvas.NewRectangle(theme.ButtonColor())
		placeholder.SetMinSize(fyne.NewSize(imgSize, imgSize))
		visualElement = container.NewStack(placeholder, iconContainer)
		visualElement.Resize(fyne.NewSize(imgSize, imgSize))
	} else {
		// *** FIX: NewAsyncImage now returns only the widget ***
		imgWidget := NewAsyncImage(imgSize, imgSize)
		imgWidget.FillMode = canvas.ImageFillContain
		// *** FIX: Call SetImageURL with correct arguments ***
		SetImageURL(imgWidget, imageURL) // Pass widget, url
		visualElement = imgWidget        // Use the widget directly
	}

	nameLabel := widget.NewLabel(name)
	nameLabel.Alignment = fyne.TextAlignCenter
	nameLabel.Truncation = fyne.TextTruncateEllipsis
	nameLabel.Wrapping = fyne.TextWrapOff
	itemContent := container.NewVBox(container.NewCenter(visualElement), nameLabel)
	itemWrapper := container.NewPadded(itemContent)
	itemWrapper.Resize(fyne.NewSize(itemWidth, itemHeight))
	card := newTappableCard(itemWrapper, func() { onSelect(itemID) })
	return card
}
