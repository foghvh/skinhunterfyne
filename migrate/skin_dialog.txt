package ui

import (
	"fmt"
	"image/color"
	"log"
	"net/url"

	"skinhunter/data" // Import your data package

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
)

// ShowSkinDialog displays the dialog with skin details and chromas
func ShowSkinDialog(skin data.Skin, parent fyne.Window) {
	log.Printf("Showing dialog for skin: %s (ID: %d)", skin.Name, skin.ID)

	// --- State for selected chroma ---
	selectedChromaID := skin.ID

	// --- Fetch Chromas (assuming skin.Chromas is populated) ---
	chromas := skin.Chromas

	// --- Left Side: Image and Description ---
	splashURL := data.GetSkinSplashURL(skin)
	splashImageContainer := LoadImageFromURL(splashURL, 350, 200)

	descriptionLabel := widget.NewLabel(skin.Description)
	if skin.Description == "" {
		descriptionLabel.SetText("This skin does not have a description.")
	}
	descriptionScroll := container.NewScroll(descriptionLabel)
	descriptionScroll.SetMinSize(fyne.NewSize(350, 100)) // SetMinSize *sí* existe para container.Scroll

	warningLabel := widget.NewLabelWithStyle("This skin may not work properly due to game updates", fyne.TextAlignLeading, fyne.TextStyle{})
	warningIcon := widget.NewIcon(theme.WarningIcon())
	warningBox := container.NewHBox(warningIcon, warningLabel)

	leftPanel := container.NewVBox(
		splashImageContainer,
		descriptionScroll,
		warningBox,
	)

	// --- Right Side: Model Viewer Link and Chromas ---
	modelViewerURL := fmt.Sprintf("https://modelviewer.lol/model-viewer?id=%d", skin.ID)
	modelViewerLink := widget.NewHyperlink("View on Model Viewer", parseURL(modelViewerURL))

	chromaTitle := widget.NewLabel("Chromas")
	chromaTabs := container.NewAppTabs()

	// -- Chroma Circles Tab --
	circlesRadioGroup := widget.NewRadioGroup([]string{}, func(selected string) {
		if selected == "Default" {
			selectedChromaID = skin.ID
		} else {
			for _, ch := range chromas {
				if fmt.Sprintf("%d", ch.ID) == selected {
					selectedChromaID = ch.ID
					break
				}
			}
		}
		log.Printf("Chroma selected (Circles): ID %d", selectedChromaID)
	})

	circlesRadioGroup.Append("Default")

	circlesGrid := container.NewGridWithColumns(4)

	// Default Item
	defaultCircleIcon := widget.NewIcon(theme.RadioButtonIcon())
	defaultCircleLabel := widget.NewLabel("Default")
	defaultCircleItem := container.NewVBox(defaultCircleIcon, defaultCircleLabel)
	circlesGrid.Add(newTappableCard(defaultCircleItem, func() { circlesRadioGroup.SetSelected(fmt.Sprintf("%d", skin.ID)) }))

	// Add chromas
	for _, chroma := range chromas {
		var colorDisplay fyne.CanvasObject
		if len(chroma.Colors) > 0 {
			clr, err := data.ParseHexColor(chroma.Colors[0])
			if err != nil {
				log.Printf("Error parsing color '%s' for chroma '%s': %v", chroma.Colors[0], chroma.Name, err)
				clr = color.NRGBA{R: 128, G: 128, B: 128, A: 255}
			}

			if len(chroma.Colors) == 1 {
				circle := canvas.NewCircle(clr)
				circle.StrokeWidth = 1
				circle.StrokeColor = theme.InputBorderColor()
				colorDisplay = circle // Usar el círculo directamente

			} else {
				clr2, err2 := data.ParseHexColor(chroma.Colors[1])
				if err2 != nil {
					log.Printf("Error parsing second color '%s' for chroma '%s': %v", chroma.Colors[1], chroma.Name, err2)
					clr2 = clr
				}
				rect1 := canvas.NewRectangle(clr)
				rect2 := canvas.NewRectangle(clr2)
				// El grid interno debería funcionar bien dentro del grid externo
				colorDisplay = container.NewGridWithColumns(2, rect1, rect2)
			}
		} else {
			// Sin color definido, usar gris
			circle := canvas.NewCircle(color.NRGBA{R: 128, G: 128, B: 128, A: 255})
			colorDisplay = circle
		}

		// No SetMinSize needed here. El tamaño será determinado por el layout.
		// Puedes ajustar el tamaño del Grid padre (circlesGrid) si es necesario,
		// o usar container.NewGridWrap si quieres que los items fluyan y tengan tamaño fijo.

		chromaLabel := widget.NewLabel(chroma.Name)
		chromaLabel.Truncation = fyne.TextTruncateEllipsis
		// Crear el VBox con el objeto de color y la etiqueta
		chromaItem := container.NewVBox(container.NewCenter(colorDisplay), container.NewCenter(chromaLabel)) // Centrar elementos puede ayudar visualmente

		chromaIDStr := fmt.Sprintf("%d", chroma.ID)
		circlesRadioGroup.Append(chromaIDStr)
		circlesGrid.Add(newTappableCard(chromaItem, func() { circlesRadioGroup.SetSelected(chromaIDStr) }))
	}
	circlesRadioGroup.SetSelected(fmt.Sprintf("%d", skin.ID))

	circlesTabContent := container.NewScroll(circlesGrid)
	chromaTabs.Append(container.NewTabItem("Circles", circlesTabContent))

	// -- Chroma Images Tab --
	imagesRadioGroup := widget.NewRadioGroup([]string{}, func(selected string) {
		if selected == "Default" {
			selectedChromaID = skin.ID
		} else {
			for _, ch := range chromas {
				if fmt.Sprintf("%d", ch.ID) == selected {
					selectedChromaID = ch.ID
					break
				}
			}
		}
		log.Printf("Chroma selected (Images): ID %d", selectedChromaID)
	})
	imagesRadioGroup.Append("Default")

	imagesGrid := container.NewGridWithColumns(4)

	// Default Item
	defaultImageIcon := widget.NewIcon(theme.RadioButtonIcon())
	defaultImageLabel := widget.NewLabel("Default")
	defaultImageItem := container.NewVBox(defaultImageIcon, defaultImageLabel)
	imagesGrid.Add(newTappableCard(defaultImageItem, func() { imagesRadioGroup.SetSelected(fmt.Sprintf("%d", skin.ID)) }))

	for _, chroma := range chromas {
		imgURL := data.GetChromaImageURL(chroma)
		imgContainer := LoadImageFromURL(imgURL, 50, 50) // LoadImageFromURL maneja el tamaño
		chromaLabel := widget.NewLabel(chroma.Name)
		chromaLabel.Truncation = fyne.TextTruncateEllipsis
		chromaItem := container.NewVBox(imgContainer, chromaLabel) // El tamaño viene de la imagen

		chromaIDStr := fmt.Sprintf("%d", chroma.ID)
		imagesRadioGroup.Append(chromaIDStr)
		imagesGrid.Add(newTappableCard(chromaItem, func() { imagesRadioGroup.SetSelected(chromaIDStr) }))
	}
	imagesRadioGroup.SetSelected(fmt.Sprintf("%d", skin.ID))

	imagesTabContent := container.NewScroll(imagesGrid)
	chromaTabs.Append(container.NewTabItem("Images", imagesTabContent))

	// --- Credits Info ---
	creditsText := "This is going to consume a credit (X credits left)" // TODO: Get actual credits
	creditsInfo := widget.NewLabel(creditsText)
	creditsInfoBox := container.NewHBox(widget.NewIcon(theme.InfoIcon()), creditsInfo)

	rightPanel := container.NewVBox(
		modelViewerLink,
		widget.NewSeparator(),
		chromaTitle,
		chromaTabs,
		creditsInfoBox,
	)

	// --- Dialog Content Layout ---
	dialogContent := container.NewHSplit(
		container.NewPadded(leftPanel),
		container.NewPadded(rightPanel),
	)
	dialogContent.Offset = 0.5

	// --- Download Button Logic ---
	downloadButton := widget.NewButtonWithIcon("Download Skin", theme.DownloadIcon(), func() {
		downloadName := skin.Name
		downloadType := "Skin"
		if selectedChromaID != skin.ID {
			downloadType = "Chroma"
			for _, ch := range chromas {
				if ch.ID == selectedChromaID {
					downloadName = ch.Name
					break
				}
			}
		}
		log.Printf("Attempting to download %s: %s (ID: %d)", downloadType, downloadName, selectedChromaID)
		// TODO: Implement download logic here
		fyne.CurrentApp().SendNotification(&fyne.Notification{
			Title:   "Download Started",
			Content: fmt.Sprintf("Downloading %s: %s", downloadType, downloadName),
		})
	})

	// --- Create and Show Dialog ---
	d := dialog.NewCustomConfirm(
		skin.Name,
		"Download",
		"Close",
		dialogContent,
		func(confirm bool) {
			if confirm {
				downloadButton.OnTapped()
			}
			log.Println("Skin dialog closed")
		},
		parent,
	)

	d.Resize(fyne.NewSize(850, 550))
	d.Show()
}

// Helper to parse URL safely for Hyperlink
func parseURL(urlStr string) *url.URL {
	u, err := url.Parse(urlStr)
	if err != nil {
		log.Printf("Error parsing URL '%s': %v", urlStr, err)
		defaultURL, _ := url.Parse("https://example.com/error")
		return defaultURL
	}
	return u
}
